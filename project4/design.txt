1. What additional properties did you add to your models and why?
	-Since I chose implement a 2-player game, user rankings would need to keep track of wins and games played. I also would not need a Score class or ScoreForms, since there is no inherent score to keep track of. Therefore it made the most sense to store wins/played under the User class. This also allows me to calculate win percentage easily with a @property.
	-In Connect 4, it is possible for a tie scenario when the board is full and neither player wins. Therefore I had to add a tie_game class method under Game. This would end the game, and register a game as played for both players, but not record either as the winner. This means that not every game has a winner, and the existence of a tie means that the average win percentage across all players is less than 0.5. The alternative would be to delete any game that ends in a tie, but I believe that more information is better.
	-Playing with a variety of board sizes is something not possible with a physical Connect 4 board. I thought that would be cool to implement so I did.

2. What were some of the trade-offs or struggles you faced when implementing the new game logic?
	-It was conceptually confusing to program the game logic at first. Since Connect 4 is a game where gravity plays a role, and your piece goes to the lowest point of the board. So despite being played in a 2-dimensional board, the moves you make are actually 1-dimensional, since you only choose which column your piece goes into. So it was important initially to define exactly the dimension and orientation in which the board was represented. In this case, I went with a ‘sideways’ representation where the ‘bottom’ of the board was at the ‘right/end’ of the 2d-array.
	-Programming the game logic with a variable board size was interesting. Every move made has a series of checks associated, first checking whether the move is valid, then whether the move was a winning move, and then whether the move filled the board. Each of these is based on the size of the board. The easiest way I found to deal with this is just to pass a reference to the board as a parameter. This way, methods had access to both the size of the board, as well as the contents of it, and could appropriately handle the checks.
	-Another difficulty I had was in debugging this application. Since the entire app is ran through APIs, I had to test cases by recreating every scenario using the google APIs explorer. An example was when I was debugging the check_full(board) method when that wasn’t working. I had to fill the board by playing for both players while ensuring that neither won the game, which was quite a hassle.

